"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[2918],{37112:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var i=n(87462),a=(n(67294),n(3905));n(8209);const s={},o="Unit Tests",r={unversionedId:"Engineering/FrontEnd/Testing/UnitTesting",id:"Engineering/FrontEnd/Testing/UnitTesting",title:"Unit Tests",description:"Unit tests should provide confidence that components perform as expected, surfacing regressions quickly whenever an issue occurs. Unit tests also serve as a form of documentation for engineers about how components should function. This document describes practices to help create simple, easy to maintain, solid, user-focused tests.",source:"@site/docs/Engineering/FrontEnd/Testing/UnitTesting.md",sourceDirName:"Engineering/FrontEnd/Testing",slug:"/Engineering/FrontEnd/Testing/UnitTesting",permalink:"/va-mobile-app/docs/Engineering/FrontEnd/Testing/UnitTesting",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Translations",permalink:"/va-mobile-app/docs/Engineering/FrontEnd/Internationalization/Translations"},next:{title:"Overview",permalink:"/va-mobile-app/docs/Engineering/DevOps/Automation Code Docs/GitHub Actions/Overview"}},l={},c=[{value:"Frameworks",id:"frameworks",level:2},{value:"Test coverage",id:"test-coverage",level:2},{value:"More information",id:"more-information",level:3},{value:"Targeting by rendered text, label, or role",id:"targeting-by-rendered-text-label-or-role",level:2},{value:"Why?",id:"why",level:3},{value:"More information",id:"more-information-1",level:3},{value:"Firing events",id:"firing-events",level:2},{value:"Why?",id:"why-1",level:3},{value:"Exercising key functionality",id:"exercising-key-functionality",level:2},{value:"Why?",id:"why-2",level:3},{value:"More information",id:"more-information-2",level:3},{value:"Testing from the user\u2019s perspective",id:"testing-from-the-users-perspective",level:2},{value:"Why?",id:"why-3",level:3},{value:"More information",id:"more-information-3",level:3},{value:"Test File Naming",id:"test-file-naming",level:2},{value:"Running Tests",id:"running-tests",level:2},{value:"Test Structure",id:"test-structure",level:2},{value:"Mocking",id:"mocking",level:2},{value:"Mocking Hooks",id:"mocking-hooks",level:3},{value:"Mocking API Calls",id:"mocking-api-calls",level:3}],p={toc:c},u="wrapper";function d(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"unit-tests"},"Unit Tests"),(0,a.kt)("p",null,"Unit tests should provide confidence that components perform as expected, surfacing regressions quickly whenever an issue occurs. Unit tests also serve as a form of documentation for engineers about how components should function. This document describes practices to help create simple, easy to maintain, solid, user-focused tests."),(0,a.kt)("h2",{id:"frameworks"},"Frameworks"),(0,a.kt)("p",null,"We run our unit tests with ",(0,a.kt)("a",{parentName:"p",href:"https://jestjs.io/"},"Jest")," and ",(0,a.kt)("a",{parentName:"p",href:"https://callstack.github.io/react-native-testing-library/"},"React Native Testing Library"),". RNTL provides a set of utility functions that make React Native component testing easier and more robust. RNTL enables many of the best practices described here."),(0,a.kt)("h2",{id:"test-coverage"},"Test coverage"),(0,a.kt)("p",null,"All React components should have at least one unit test. The ideal quantity of test coverage depends on component type. Examining component types from most coverage to least:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Shared components")," are isolated bundles of code which many other components consume. Because shared components are widely used, unit tests should exercise them very thoroughly, including checking all edge cases and error states. (Maximum coverage)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Screen child components")," are usually not shared and are tightly bound to other components in the screen. Unit tests for these child components should focus on complicated logic that's prone to regressions, while avoiding duplicate coverage between parent and child components. Tests should cover edge cases and error states, but need not check every possible combination of props and state. (High coverage)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Entire screens")," are typically complex, integrating multiple components along with Redux state, routing, and 3rd party modules. We lean on E2E tests to fully cover screens, so unit tests for screens should be limited in scope to avoid duplicating E2E test coverage. Also if a child component of a screen already has its own unit tests, there's no need to duplicate those tests in the screen itself. (Medium coverage)")),(0,a.kt)("p",null,"Note that while a high coverage percentage is good, it doesn't ensure tests are complete and correct. It's important to think critically and implement tests that cover the key cases a user might encounter."),(0,a.kt)("h3",{id:"more-information"},"More information"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Google's ",(0,a.kt)("a",{parentName:"li",href:"https://testing.googleblog.com/2020/08/code-coverage-best-practices.html"},"Code Coverage Best Practices")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://kentcdodds.com/blog/how-to-know-what-to-test"},"How to know what to test")," (Kent C Dodds)")),(0,a.kt)("h2",{id:"targeting-by-rendered-text-label-or-role"},"Targeting by rendered text, label, or role"),(0,a.kt)("p",null,"\u274c"," Avoid targeting child props based on numeric order:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"expect(textView[5].props.children).toEqual('Rx #: 3636691')\n")),(0,a.kt)("p",null,"\u2705"," Instead, target rendered text, role, or accessibility label:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"expect(screen.getByText('Rx #: 3636691')).toBeTruthy()\nexpect(screen.getByLabelText('Prescription number 3636691')).toBeTruthy()\nexpect(screen.getByRole('checkbox', { name: 'Prescription 1 of 3', checked: true })).toBeTruthy()\n")),(0,a.kt)("h3",{id:"why"},"Why?"),(0,a.kt)("p",null,"This method reduces test fragility because moving an element into/out of a child component, changing props, or adding/removing sibling components does not break the test. Targeting accessibility label or role ensures screen readers read the correct label and/or role to the user, preventing a11y regressions. Finally, this type of test is simpler to read and write because it ignores implementation details, focusing instead on what the user expects to see in rendered output. "),(0,a.kt)("h3",{id:"more-information-1"},"More information"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"React Testing Library's ",(0,a.kt)("a",{parentName:"li",href:"https://testing-library.com/docs/guiding-principles"},"guiding principles")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.boyney.io/blog/2019-05-21-my-experience-moving-from-enzyme-to-react-testing-library"},"Some thoughts")," on why this RTL approach is an improvement over Enzyme"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://mskelton.medium.com/the-dangers-of-shallow-rendering-343e48fe5f28"},"The Dangers of Shallow Rendering"))),(0,a.kt)("h2",{id:"firing-events"},"Firing events"),(0,a.kt)("p",null,"\u274c"," Avoid calling a callback function in a prop to simulate user interaction:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"testInstance.findByType(Pressable).props.onPress()\n")),(0,a.kt)("p",null,"\u2705"," Instead, fire a press event:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"fireEvent.press(screen.getByText('Cancel'))\n")),(0,a.kt)("p",null,"\u2705"," Fire a changeText event:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"fireEvent.changeText(screen.getByText('Phone'), '123-456-7890');\n")),(0,a.kt)("p",null,"\u2705"," Fire a scroll event:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"fireEvent.scroll(screen.getByText('scroll-view'), {\n  nativeEvent: { contentOffset: { y: 200 } }\n})\n")),(0,a.kt)("h3",{id:"why-1"},"Why?"),(0,a.kt)("p",null,"Calling a callback function in a prop only checks that the function runs. It doesn\u2019t test that the element is visible to the user and that it\u2019s wired up correctly. It\u2019s also fragile because refactoring the component might change the props and break the test. Firing an event resolves these concerns, which also apply to text fields and scrolling."),(0,a.kt)("h2",{id:"exercising-key-functionality"},"Exercising key functionality"),(0,a.kt)("p",null,"\u274c"," Avoid tests that just check large quantities of static props:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"expect(textView[6].props.children).toEqual('What\u2019s next')\nexpect(textView[7].props.children).toEqual(\"We're reviewing your refill request. Once approved, the VA pharmacy will process your refill.\")\nexpect(textView[8].props.children).toEqual('If you have questions about the status of your refill, contact your provider or local VA pharmacy.')\n")),(0,a.kt)("p",null,"\u2705"," Instead, focus on tests that check important functionality:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"describe('on click of the \"Go to inbox\" button', () => {\n  it('calls useRouteNavigation and updateSecureMessagingTab', () => {\n    fireEvent.press(screen.getByText('Go to inbox'))\n    expect(navigate).toHaveBeenCalled()\n    expect(updateSecureMessagingTab).toHaveBeenCalled()\n  })\n})\n")),(0,a.kt)("h3",{id:"why-2"},"Why?"),(0,a.kt)("p",null,"Each test should add value by serving as a focused warning that something important has failed. Testing that a sequence of TextViews renders certain text doesn't tell us much. It's also fragile because the smallest text change breaks the test. Testing important and/or complex logic is more beneficial because that\u2019s where high-impact regressions typically occur. In addition, tests for complicated logic serve as a form of documentation, letting engineers know how the code is supposed to function."),(0,a.kt)("h3",{id:"more-information-2"},"More information"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"See #2 of ",(0,a.kt)("a",{parentName:"li",href:"https://www.testrail.com/blog/the-7-sins-of-unit-testing/"},"The 7 Sins of Unit Testing")," about why more assertions can be worse, not better")),(0,a.kt)("h2",{id:"testing-from-the-users-perspective"},"Testing from the user\u2019s perspective"),(0,a.kt)("p",null,"Consider what the user expects to do and see, then write tests that simulate it. For example, let's say the user expects to press \u201cSelect all\u201d, then see two checked checkboxes and relevant text."),(0,a.kt)("p",null,"\u2705"," This test tells the user's story and checks it at the same time:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"it('toggles items when \"Select all\" is pressed', () => {\n    fireEvent.press(screen.getByText('Select all'))\n    expect(screen.getByRole('checkbox', { name: 'One', checked: true })).toBeTruthy()\n    expect(screen.getByRole('checkbox', { name: 'Two', checked: true })).toBeTruthy()\n    expect(screen.getByText('2/2 selected')).toBeTruthy()\n})\n")),(0,a.kt)("h3",{id:"why-3"},"Why?"),(0,a.kt)("p",null,"By taking the user's point of view, user-focused tests help prevent the most damaging regressions, ones which prevent users from completing their desired tasks. But because implementation details aren't baked into the test, engineers retain the flexibility to refactor as needed without causing test failures."),(0,a.kt)("h3",{id:"more-information-3"},"More information"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Why it's important to focus on the ",(0,a.kt)("a",{parentName:"li",href:"https://kentcdodds.com/blog/avoid-the-test-user"},"end user"),' and avoid the "test user"')),(0,a.kt)("h2",{id:"test-file-naming"},"Test File Naming"),(0,a.kt)("p",null,"The test file should live in the same location as its associated component with the same file name with .test included after the component name."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"ClaimsScreen.tsx")," will have a test file named ",(0,a.kt)("inlineCode",{parentName:"p"},"ClaimsScreen.test.tsx")),(0,a.kt)("h2",{id:"running-tests"},"Running Tests"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Run unit tests with ",(0,a.kt)("inlineCode",{parentName:"li"},"yarn test")),(0,a.kt)("li",{parentName:"ul"},"Coverage can be found under ",(0,a.kt)("inlineCode",{parentName:"li"},"coverage/lcov-report/index.html"))),(0,a.kt)("h2",{id:"test-structure"},"Test Structure"),(0,a.kt)("p",null,"Unit tests are structured into ",(0,a.kt)("inlineCode",{parentName:"p"},"context"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"describe"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"it")," functions that provide context to the tests as they are run. These are presented as a readable heirarchy, making it easy to follow the output of the tests and identify where failing tests are and what they were testing."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"context('MyScreen', () => {\n  describe('when loading is set to true', () => {\n    it('should show loading screen', async () => {\n      // testing\n    })\n\n    it('should not show a menu', async () => {\n      // testing\n    })\n  })\n})\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"context")," is typically the name of the component or screen, the primary identifier of what this file is testing. ",(0,a.kt)("inlineCode",{parentName:"p"},"describe")," provides a specific circumstance or set of properties. ",(0,a.kt)("inlineCode",{parentName:"p"},"it")," explains exactly what is being tested. A ",(0,a.kt)("inlineCode",{parentName:"p"},"context")," can have as many ",(0,a.kt)("inlineCode",{parentName:"p"},"describe")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"it")," functions as is necessary to describe the flow of the test."),(0,a.kt)("h2",{id:"mocking"},"Mocking"),(0,a.kt)("p",null,"Components often interact with other pieces of code that are not the responsibility of that unit test, but rely on them to function. To handle these cases, we use mocks to guarantee inputs and outputs of things like navigation actions, API calls, external libraries, hooks, or anything else the component might need but does not control the logic of."),(0,a.kt)("p",null,"Mocking libraries and functions are done through ",(0,a.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/mock-functions"},"jest mocks"),". Global mocks can be found at ",(0,a.kt)("inlineCode",{parentName:"p"},"jest/testSetup.ts")," but can be overridden within the individual test files."),(0,a.kt)("h3",{id:"mocking-hooks"},"Mocking Hooks"),(0,a.kt)("p",null,"One of the most commonly mocked parts of the app are hooks related to things like navigation, theme, and alerts. This is done by creating a spy object at the top of the file that will then be set in the jest mocks to allow it to be used within the tests."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"let mockNavigationSpy = jest.fn()\njest.mock('utils/hooks', () => {\n  let original = jest.requireActual('utils/hooks')\n  return {\n    ...original,\n    useRouteNavigation: () => {\n      return mockNavigationSpy\n    },\n  }\n})\n")),(0,a.kt)("p",null,"This block of code will mock the entirety of the hooks util file using the original implementations except for the useRouteNavigation hook, which is instead returning a spy object that the unit test can use to verify it was called with the correct arguments."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"navigateToPaymentMissingSpy = jest.fn()\n\nwhen(mockNavigationSpy)\n      .mockReturnValue(() => {})\n      .calledWith('PaymentMissing')\n      .mockReturnValue(navigateToPaymentMissingSpy)\n")),(0,a.kt)("p",null,"This will create another object  ",(0,a.kt)("inlineCode",{parentName:"p"},"navigateToPaymentMissingSpy")," that will be returned if the hook is called with the parameters ",(0,a.kt)("inlineCode",{parentName:"p"},"'PaymentMissing'")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"// Do something that will trigger a navigation to the PaymentMissing screen\nexpect(navigateToPaymentMissingSpy).toHaveBeenCalled()\n")),(0,a.kt)("h3",{id:"mocking-api-calls"},"Mocking API Calls"),(0,a.kt)("p",null,"Components will often make API calls which can be mocked via the redux actions that call them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"import { downloadLetter } from 'store/slices'\n\njest.mock('store/slices', () => {\n  let actual = jest.requireActual('store/slices')\n  return {\n    ...actual,\n    downloadLetter: jest.fn(() => {\n      return {\n        type: '',\n        payload: '',\n      }\n    }),\n  }\n})\n")),(0,a.kt)("p",null,"This imports the ",(0,a.kt)("inlineCode",{parentName:"p"},"downloadLetter")," action from the letters slice responsible for handling downloading letters and mocks it to do nothing. This will let the unit test validate it has been called without the test itself trying to actually download anything."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-tsx"},"// Do something that triggers downloading of a letter with some set of options\n\nconst letterOptions = {\n  chapter35Eligibility: true,\n  militaryService: true,\n  monthlyAward: true,\n  serviceConnectedDisabilities: true,\n  serviceConnectedEvaluation: true,\n}\nexpect(downloadLetter).toBeCalledWith(LetterTypeConstants.benefitSummary, letterOptions)\n")),(0,a.kt)("p",null,"This checks to see that the ",(0,a.kt)("inlineCode",{parentName:"p"},"downloadLetter")," action was called with the expected parameters"))}d.isMDXComponent=!0}}]);