"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[4100],{9540:(e,r,n)=>{n.d(r,{d:()=>o});var t=n(72077);const o=e=>(0,t.Ay)()["docusaurus-plugin-react-docgen-typescript"].default.filter((r=>r.displayName===e))},64555:(e,r,n)=>{n.d(r,{A:()=>p});n(96540);var t=n(58069),o=n(65537),s=n(79329),i=n(9540),a=n(84476),l=n(74848);const d=({props:e})=>e?(0,l.jsx)(l.Fragment,{children:a.Ay.isEmpty(e)?(0,l.jsx)("pre",{className:"preText",children:"This component does not have props defined"}):(0,l.jsxs)("table",{children:[(0,l.jsx)("thead",{children:(0,l.jsxs)("tr",{children:[(0,l.jsx)("th",{children:"Name"}),(0,l.jsx)("th",{children:"Type"}),(0,l.jsx)("th",{children:"Default Value"}),(0,l.jsx)("th",{children:"Required"}),(0,l.jsx)("th",{children:"Description"})]})}),(0,l.jsx)("tbody",{children:Object.keys(e).map((r=>(0,l.jsxs)("tr",{children:[(0,l.jsx)("td",{children:(0,l.jsx)("code",{children:r})}),(0,l.jsx)("td",{style:{minWidth:200},children:e[r].type?.name}),(0,l.jsx)("td",{children:e[r].defaultValue&&e[r].defaultValue.value.toString()}),(0,l.jsx)("td",{children:e[r].required?"Yes":"No"}),(0,l.jsx)("td",{children:e[r].description})]},r)))})]})}):null;function p(e){const r=(0,i.d)(e.componentName),{description:n,displayName:a,props:p}=r[0],c=`How to use the ${a} component`,u=`Full code for the ${a} component`;return(0,l.jsxs)(l.Fragment,{children:[n,(0,l.jsx)("br",{}),(0,l.jsx)("br",{}),(0,l.jsxs)(o.A,{children:[(0,l.jsx)(s.A,{value:"props",label:"Properties",children:(0,l.jsx)(d,{props:p})}),(0,l.jsx)(s.A,{value:"example",label:"Example",children:e.example&&(0,l.jsx)(t.A,{title:c,className:"language-tsx test",children:e.example})}),(0,l.jsx)(s.A,{value:"code",label:"Source Code",children:e.codeString&&(0,l.jsx)(t.A,{title:u,className:"language-tsx",children:e.codeString})}),(0,l.jsx)(s.A,{value:"accessibility",label:"Accessibility",children:(0,l.jsx)("pre",{className:"preText",children:e.accessibilityInfo})})]})]})}},89552:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>p,contentTitle:()=>d,default:()=>f,exampleString:()=>c,frontMatter:()=>l,metadata:()=>t,toc:()=>u});const t=JSON.parse('{"id":"Flagship design library/Components/Selection and Input/Form Elements/FormWrapper","title":"FormWrapper","description":"","source":"@site/docs/Flagship design library/Components/Selection and Input/Form Elements/FormWrapper.mdx","sourceDirName":"Flagship design library/Components/Selection and Input/Form Elements","slug":"/Flagship design library/Components/Selection and Input/Form Elements/FormWrapper","permalink":"/va-mobile-app/docs/Flagship design library/Components/Selection and Input/Form Elements/FormWrapper","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"FormAttachments","permalink":"/va-mobile-app/docs/Flagship design library/Components/Selection and Input/Form Elements/FormAttachments"},"next":{"title":"Radio button","permalink":"/va-mobile-app/docs/Flagship design library/Components/Selection and Input/Form Elements/RadioButton"}}');var o=n(74848),s=n(28453);n(58069);const i="import React, { ReactElement, useCallback, useEffect, useState } from 'react'\n\nimport _ from 'underscore'\n\nimport {\n  Box,\n  ComboBoxInput,\n  ComboBoxInputProps,\n  FormAttachments,\n  FormAttachmentsProps,\n  RadioGroup,\n  RadioGroupProps,\n  VAModalPicker,\n  VAModalPickerProps,\n  VASelector,\n  VASelectorProps,\n  VATextInput,\n  VATextInputProps,\n} from 'components/index'\nimport { useTheme } from 'utils/hooks'\n\n/** enum to determine field input type */\nexport enum FieldType {\n  Selector = 'Selector',\n  Picker = 'Picker',\n  TextInput = 'TextInput',\n  Radios = 'Radios',\n  FormAttachmentsList = 'FormAttachmentsList',\n  ComboBox = 'Combobox',\n}\n\n/** contains function to compare against on save and on focus/blur, and its corresponding error message if the function fails */\nexport type ValidationFunctionItems = {\n  /** function that returns true if the validation fails */\n  validationFunction: () => boolean\n  /** error message to display if the validation fails */\n  validationFunctionErrorMessage: string\n}\n\n/** form field type that includes the index of the field in the list so that it can be used to find a specific field */\ntype FormFieldTypeWithUId<T> = Pick<FormFieldType<T>, 'fieldType' | 'fieldProps' | 'fieldErrorMessage'> & {\n  index: number\n}\n\nexport type FormFieldType<T> = {\n  /** enum to determine if the field is a picker, text input, or checkbox selector */\n  fieldType: FieldType\n  /** props to pass into form input component */\n  fieldProps:\n    | VASelectorProps\n    | VATextInputProps\n    | VAModalPickerProps\n    | RadioGroupProps<T>\n    | FormAttachmentsProps\n    | ComboBoxInputProps\n  /** optional error message to display if the field is required and it hasn't been filled */\n  fieldErrorMessage?: string\n  /** optional boolean that prevents the field from being displayed when set to true */\n  hideField?: boolean\n  /** optional list of validation functions to check against */\n  validationList?: Array<ValidationFunctionItems>\n}\n\n/**\n * Props for FormWrapper component\n */\ntype FormWrapperProps<T> = {\n  /** list of form field objects to display */\n  fieldsList: Array<FormFieldType<T>>\n  /** callback called when onSaveClicked is true and there are no field errors */\n  onSave: () => void\n  /** boolean that when set to true calls the form validation and set field errors if they exist, otherwise it calls onSave */\n  onSaveClicked: boolean\n  /** callback that updates the onSaveClicked prop */\n  setOnSaveClicked: (value: boolean) => void\n  /** optional callback that sets to true if the form currently has an error */\n  setFormContainsError?: (containsError: boolean) => void\n  /** optional boolean that resets all field errors when set to true */\n  resetErrors?: boolean\n  /** optional callback to set the resetErrors prop. must be set when resetErrors is set. */\n  setResetErrors?: (value: boolean) => void\n  /** optional callback to return a list of errors and keys for alertBox functionality  */\n  setErrorList?: (errors: { [key: number]: string }) => void\n}\n\n/**A common component to wrap forms in that handles error states of each field*/\nconst FormWrapper = <T,>({\n  fieldsList,\n  onSave,\n  setFormContainsError,\n  resetErrors,\n  setResetErrors,\n  onSaveClicked,\n  setOnSaveClicked,\n  setErrorList,\n}: FormWrapperProps<T>): ReactElement => {\n  const theme = useTheme()\n  const [errors, setErrors] = useState<{ [key: number]: string }>({})\n\n  const updateFormContainsErrors = useCallback(\n    (value: boolean) => {\n      setFormContainsError && setFormContainsError(value)\n    },\n    [setFormContainsError],\n  )\n\n  useEffect(() => {\n    // if resetErrors is true, it clears the errors object\n    if (resetErrors) {\n      setErrors({})\n      updateFormContainsErrors(false)\n      setResetErrors && setResetErrors(false)\n      setErrorList && setErrorList([])\n    }\n  }, [resetErrors, setErrors, updateFormContainsErrors, setResetErrors, setErrorList])\n\n  // when onSaveClicked is true, it checks if all required fields are filled and if the validation functions pass. if true,\n  // calls onSave callback, otherwise calls setErrorsOnFormSaveFailure to update the error messages for the required\n  // fields that are not filled / failing validation functions\n  const onFormSave = useCallback(() => {\n    // Adds the field \"index\", which is the index of the field in the fieldsList, to each item\n    const getFieldListsWithIndexes = (): Array<FormFieldTypeWithUId<T>> => {\n      return fieldsList.map((obj, index) => ({ ...obj, index }))\n    }\n\n    // Using the fieldsList with the index fields, this returns all fields that are required but are\n    // empty or set to false (checkbox)\n    const getAllRequiredFieldsNotFilled = (): Array<FormFieldTypeWithUId<T>> => {\n      const fieldsListWithUIds = getFieldListsWithIndexes()\n\n      return fieldsListWithUIds.filter((el) => {\n        switch (el.fieldType) {\n          case FieldType.TextInput:\n            const textInputProps = el.fieldProps as VATextInputProps\n            return !textInputProps.value && textInputProps.isRequiredField\n          case FieldType.Picker:\n            const pickerProps = el.fieldProps as VAModalPickerProps\n            return !pickerProps.selectedValue && pickerProps.isRequiredField\n          case FieldType.Selector:\n            const checkboxProps = el.fieldProps as VASelectorProps\n            return !checkboxProps.selected && checkboxProps.isRequiredField\n          case FieldType.ComboBox:\n            const comboBoxProps = el.fieldProps as ComboBoxInputProps\n            return !comboBoxProps.selectedValue && comboBoxProps.isRequiredField\n          case FieldType.Radios:\n            const radioProps = el.fieldProps as RadioGroupProps<T>\n            return !radioProps.value && radioProps.isRequiredField\n          default:\n            // default returns false because the radio group and form attachments will not have field errors\n            return false\n        }\n      })\n    }\n\n    // Iterates over all required form fields that are not filled and updates the error messages for these fields\n    const setErrorsOnFormSaveFailure = (\n      requiredFieldsNotFilled: Array<FormFieldTypeWithUId<T>>,\n      errorsFromValidationFunctions: { [key: number]: string },\n    ): void => {\n      const updatedErrors: { [key: number]: string } = {}\n      _.forEach(requiredFieldsNotFilled, (field) => {\n        updatedErrors[field.index] = field.fieldErrorMessage || ''\n      })\n\n      const updatedErrorsObj = { ...errors, ...errorsFromValidationFunctions, ...updatedErrors }\n\n      setErrors(updatedErrorsObj)\n      setErrorList && setErrorList(updatedErrorsObj)\n    }\n\n    // Returns any errors to be set if a validation function failed\n    const checkAgainstValidationFunctions = () => {\n      const updatedErrors: { [key: number]: string } = {}\n\n      _.forEach(fieldsList, (field, index) => {\n        if (field.validationList) {\n          const result = field.validationList.filter((el) => {\n            return el.validationFunction()\n          })\n\n          // if there are items in the result that means that that validation function failed\n          if (result.length > 0) {\n            _.forEach(result, (item) => {\n              updatedErrors[index] = item.validationFunctionErrorMessage\n            })\n          }\n        }\n      })\n\n      return updatedErrors\n    }\n\n    const requiredFieldsNotFilled = getAllRequiredFieldsNotFilled()\n    const errorsFromValidationFunctions = checkAgainstValidationFunctions()\n\n    if (requiredFieldsNotFilled.length === 0 && _.isEmpty(errorsFromValidationFunctions)) {\n      if (!_.isEmpty(errors)) {\n        setErrors({})\n      }\n\n      updateFormContainsErrors(false)\n      onSave()\n    } else {\n      updateFormContainsErrors(true)\n      setErrorsOnFormSaveFailure(requiredFieldsNotFilled, errorsFromValidationFunctions)\n    }\n  }, [onSave, updateFormContainsErrors, errors, fieldsList, setErrorList])\n\n  useEffect(() => {\n    if (onSaveClicked) {\n      onFormSave()\n      setOnSaveClicked(false)\n    }\n  }, [onSaveClicked, onFormSave, setOnSaveClicked])\n\n  // sets the field error in the errors object based on its index, if its a string it sets it to the given errorMessage\n  // otherwise, it sets it to the fieldErrorMessage if it exists\n  const setFormError = (\n    errorMessage: string | undefined,\n    index: number,\n    fieldErrorMessage: string | undefined,\n  ): void => {\n    if (typeof errorMessage === 'string') {\n      const updatedErrors = { ...errors, [index]: errorMessage }\n      setErrors(updatedErrors)\n      const errorStillExists = _.values(updatedErrors).some((el) => el !== '')\n\n      if (errorStillExists) {\n        updateFormContainsErrors(true)\n      }\n\n      return\n    }\n\n    updateFormContainsErrors(true)\n\n    if (fieldErrorMessage) {\n      setErrors({ ...errors, [index]: fieldErrorMessage })\n    }\n  }\n\n  // returns the corresponding component based on the fields fieldType\n  const getFormComponent = (field: FormFieldType<T>, index: number): ReactElement => {\n    const { fieldType, fieldProps, fieldErrorMessage } = field\n\n    switch (fieldType) {\n      case FieldType.Picker:\n        return (\n          <VAModalPicker\n            {...(fieldProps as VAModalPickerProps)}\n            setError={(errorMessage?: string) => setFormError(errorMessage, index, fieldErrorMessage)}\n            error={errors[index]}\n          />\n        )\n      case FieldType.TextInput:\n        return (\n          <VATextInput\n            {...(fieldProps as VATextInputProps)}\n            setError={(errorMessage?: string) => setFormError(errorMessage, index, fieldErrorMessage)}\n            error={errors[index]}\n          />\n        )\n      case FieldType.Selector:\n        return (\n          <VASelector\n            {...(fieldProps as VASelectorProps)}\n            setError={(errorMessage?: string) => setFormError(errorMessage, index, fieldErrorMessage)}\n            error={errors[index]}\n          />\n        )\n      case FieldType.Radios:\n        return (\n          <RadioGroup\n            {...(fieldProps as RadioGroupProps<T>)}\n            setError={(errorMessage?: string) => setFormError(errorMessage, index, fieldErrorMessage)}\n            error={errors[index]}\n          />\n        )\n      case FieldType.FormAttachmentsList:\n        return <FormAttachments {...(fieldProps as FormAttachmentsProps)} />\n      case FieldType.ComboBox:\n        return (\n          <ComboBoxInput\n            {...(fieldProps as ComboBoxInputProps)}\n            setError={(errorMessage?: string) => setFormError(errorMessage, index, fieldErrorMessage)}\n            error={errors[index]}\n          />\n        )\n    }\n  }\n\n  const generateForm = (): ReactElement[] => {\n    return _.map(fieldsList, (field, index) => {\n      return (\n        <Box\n          mt={index === 0 ? 0 : theme.dimensions.formMarginBetween}\n          key={index}\n          display={field.hideField ? 'none' : undefined}>\n          {getFormComponent(field, index)}\n        </Box>\n      )\n    })\n  }\n\n  return <Box>{generateForm()}</Box>\n}\n\nexport default FormWrapper\n";var a=n(64555);const l={},d=void 0,p={},c="<FormWrapper \nfieldsList={pickerField} \nonSave={onUpload} \nonSaveClicked={onSaveClicked} \nsetOnSaveClicked={setOnSaveClicked} />",u=[];function m(e){return(0,o.jsx)(a.A,{componentName:"FormWrapper",example:c,codeString:i})}function f(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,o.jsx)(r,{...e,children:(0,o.jsx)(m,{...e})}):m()}}}]);