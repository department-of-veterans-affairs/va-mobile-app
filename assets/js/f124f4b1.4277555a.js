"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[7499],{28453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>l});var r=n(96540);const a={},i=r.createContext(a);function s(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:t},e.children)}},61872:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>d,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"Engineering/BackEnd/Architecture/ParallelCalls","title":"Parallel Calls","description":"The mobile API often needs to make requests to external services to fetch data to return to the client. In some cases, a single request from the client can require data from multiple external services. This can cause those requests to be slow and creates a bad user experience.","source":"@site/docs/Engineering/BackEnd/Architecture/ParallelCalls.md","sourceDirName":"Engineering/BackEnd/Architecture","slug":"/Engineering/BackEnd/Architecture/ParallelCalls","permalink":"/va-mobile-app/docs/Engineering/BackEnd/Architecture/ParallelCalls","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Parallel Calls"},"sidebar":"tutorialSidebar","previous":{"title":"OpenAPI Documentation","permalink":"/va-mobile-app/docs/Engineering/BackEnd/Architecture/OpenAPIDocumentation"},"next":{"title":"Record Filtering","permalink":"/va-mobile-app/docs/Engineering/BackEnd/Architecture/RecordFiltering"}}');var a=n(74848),i=n(28453);const s={title:"Parallel Calls"},l=void 0,o={},c=[];function u(e){const t={a:"a",code:"code",li:"li",p:"p",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"The mobile API often needs to make requests to external services to fetch data to return to the client. In some cases, a single request from the client can require data from multiple external services. This can cause those requests to be slow and creates a bad user experience."}),"\n",(0,a.jsxs)(t.p,{children:["To mitigate the issue, we use the ",(0,a.jsx)(t.a,{href:"https://github.com/grosser/parallel",children:"Parallel Gem"}),", which provides a simple interface for executing functions in parallel using threads. A simple use pattern is:"]}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:"Find the common location where code branches off into the multiple network calls."}),"\n",(0,a.jsx)(t.li,{children:"Wrap the methods that initiate those branches in lambdas."}),"\n",(0,a.jsxs)(t.li,{children:["Pass an array of those lambdas to the gem, telling it how many threads to use and specifying that it should execute the ",(0,a.jsx)(t.code,{children:"call"})," method on each lambda to execute it."]}),"\n",(0,a.jsx)(t.li,{children:"Capture return values if needed."}),"\n",(0,a.jsx)(t.li,{children:"It is possible to rescue errors either within lambdas or around the entire parallelization code block. This allows us the ability to capture errors and either log them or provide helpful information back to the client. If we do not rescue, errors will stop execution and be handled as they normally would."}),"\n"]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}}}]);