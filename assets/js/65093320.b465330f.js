"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[8221],{28453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>r});var o=t(96540);const i={},a=o.createContext(i);function s(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(a.Provider,{value:n},e.children)}},55230:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"FrontEnd/RemoteConfig","title":"Remote config","description":"Remote Configuration (Feature Flipper/Toggles)","source":"@site/development/FrontEnd/RemoteConfig.md","sourceDirName":"FrontEnd","slug":"/FrontEnd/RemoteConfig","permalink":"/va-mobile-app/development/FrontEnd/RemoteConfig","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"title":"Remote config"},"sidebar":"tutorialSidebar","previous":{"title":"Push notifications","permalink":"/va-mobile-app/development/FrontEnd/Push Notifications"},"next":{"title":"Single sign-on","permalink":"/va-mobile-app/development/FrontEnd/SingleSignOn"}}');var i=t(74848),a=t(28453);const s={title:"Remote config"},r=void 0,l={},d=[{value:"Background",id:"background",level:2},{value:"Environments",id:"environments",level:2},{value:"Guidelines",id:"guidelines",level:2},{value:"Data Schema",id:"data-schema",level:2},{value:"Example",id:"example",level:3}];function c(e){const n={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.p,{children:"Remote Configuration (Feature Flipper/Toggles)"}),"\n",(0,i.jsx)(n.h2,{id:"background",children:"Background"}),"\n",(0,i.jsx)(n.p,{children:"Due of the growing complexity of the Flagship app and the types of features we are incorporating, we have an increasing need for the ability to manage aspects of the app remotely. In mobile, as in web, the best way to do this is by incorporating a remote configuration that allows features, behavior, and appearance aspects of the app to be updated without issuing a full app update."}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://firebase.google.com/docs/remote-config",children:"Firebase's Remote Config"})," product allows us to store and modify values remotely, enable or disable certain app features, as well as roll them out to a certain percentage of users at a time."]}),"\n",(0,i.jsx)(n.h2,{id:"environments",children:"Environments"}),"\n",(0,i.jsxs)(n.p,{children:["The values set in Firebase are for production only. Any overrides we'll use for development or in QA will be stored and overridden in our FE code in ",(0,i.jsx)(n.code,{children:"src/utils/remoteConfig.ts"}),".  The app will only fetch values from Firebase if it detects that our ",(0,i.jsx)(n.code,{children:"ENVIRONMENT === 'Production'"}),". Otherwise it will use the defaults for staging/dev that are set in ",(0,i.jsx)(n.code,{children:"remoteConfig.ts"})]}),"\n",(0,i.jsx)(n.h2,{id:"guidelines",children:"Guidelines"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"The feature for consideration should be relatively self-contained and require a minimal amount of logic to switch between its enabled and disabled state (e.g. request appointment flow)"}),"\n",(0,i.jsx)(n.li,{children:"Addition of a new remote config value should be approved by the mobile platform team"}),"\n",(0,i.jsxs)(n.li,{children:["Values should be named using snake case (i.e. ",(0,i.jsx)(n.code,{children:"my_test_value"}),")"]}),"\n",(0,i.jsxs)(n.li,{children:["Values should be named using the feature by itself, and not any boolean indicating prefix or suffix such as ",(0,i.jsx)(n.code,{children:"is"})," or ",(0,i.jsx)(n.code,{children:"enabled"})]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"data-schema",children:"Data Schema"}),"\n",(0,i.jsx)(n.p,{children:"While the number of remote config values we have will be small, it's important that we set some guidelines about naming conventions and structure of our configurations as they grow."}),"\n",(0,i.jsx)(n.p,{children:"Firebase allows for 4 different data types:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"String"}),"\n",(0,i.jsx)(n.li,{children:"Boolean"}),"\n",(0,i.jsx)(n.li,{children:"Number"}),"\n",(0,i.jsx)(n.li,{children:"JSON"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"For the foreseeable future, we'll only make use of the Boolean data type."}),"\n",(0,i.jsx)(n.p,{children:"The data schema will be a flat structure consisting of booleans:"}),"\n",(0,i.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-json",children:'{\n  "SIS": true,\n  "prescriptions": false,\n  "appointment_requests": false\n}\n'})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}}}]);