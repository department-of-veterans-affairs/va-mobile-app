"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[4100],{7644:(e,r,n)=>{n.d(r,{A:()=>p});var t=n(96540),o=n(54610),s=n(3384),i=n(31347),a=n(28057),l=n(84476);const d=e=>{let{props:r}=e;return r?t.createElement(t.Fragment,null,l.Ay.isEmpty(r)?t.createElement("pre",{className:"preText"},"This component does not have props defined"):t.createElement("table",null,t.createElement("thead",null,t.createElement("tr",null,t.createElement("th",null,"Name"),t.createElement("th",null,"Type"),t.createElement("th",null,"Default Value"),t.createElement("th",null,"Required"),t.createElement("th",null,"Description"))),t.createElement("tbody",null,Object.keys(r).map((e=>t.createElement("tr",{key:e},t.createElement("td",null,t.createElement("code",null,e)),t.createElement("td",{style:{minWidth:200}},r[e].type?.name),t.createElement("td",null,r[e].defaultValue&&r[e].defaultValue.value.toString()),t.createElement("td",null,r[e].required?"Yes":"No"),t.createElement("td",null,r[e].description))))))):null};function p(e){const r=(0,a.d)(e.componentName),{description:n,displayName:l,props:p}=r[0],c=`How to use the ${l} component`,m=`Full code for the ${l} component`;return t.createElement(t.Fragment,null,n,t.createElement("br",null),t.createElement("br",null),t.createElement(s.A,null,t.createElement(i.A,{value:"props",label:"Properties"},t.createElement(d,{props:p})),t.createElement(i.A,{value:"example",label:"Example"},e.example&&t.createElement(o.A,{title:c,className:"language-tsx test"},e.example)),t.createElement(i.A,{value:"code",label:"Source Code"},e.codeString&&t.createElement(o.A,{title:m,className:"language-tsx"},e.codeString)),t.createElement(i.A,{value:"accessibility",label:"Accessibility"},t.createElement("pre",{className:"preText"},e.accessibilityInfo))))}},28057:(e,r,n)=>{n.d(r,{d:()=>o});var t=n(2736);const o=e=>(0,t.Ay)()["docusaurus-plugin-react-docgen-typescript"].default.filter((r=>r.displayName===e))},95119:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>p,contentTitle:()=>l,default:()=>F,exampleString:()=>m,frontMatter:()=>a,metadata:()=>d,toc:()=>c});var t=n(58168),o=(n(96540),n(15680));n(41873),n(54610);const s="import React, { ReactElement, useCallback, useEffect, useState } from 'react'\n\nimport _ from 'lodash'\n\nimport { useTheme } from 'utils/hooks'\n\nimport {\n  Box,\n  FormAttachments,\n  FormAttachmentsProps,\n  RadioGroup,\n  RadioGroupProps,\n  VAModalPicker,\n  VAModalPickerProps,\n  VASelector,\n  VASelectorProps,\n  VATextInput,\n  VATextInputProps,\n} from '../index'\n\n/** enum to determine field input type */\nexport enum FieldType {\n  Selector = 'Selector',\n  Picker = 'Picker',\n  TextInput = 'TextInput',\n  Radios = 'Radios',\n  FormAttachmentsList = 'FormAttachmentsList',\n}\n\n/** contains function to compare against on save and on focus/blur, and its corresponding error message if the function fails */\nexport type ValidationFunctionItems = {\n  /** function that returns true if the validation fails */\n  validationFunction: () => boolean\n  /** error message to display if the validation fails */\n  validationFunctionErrorMessage: string\n}\n\n/** form field type that includes the index of the field in the list so that it can be used to find a specific field */\ntype FormFieldTypeWithUId<T> = Pick<FormFieldType<T>, 'fieldType' | 'fieldProps' | 'fieldErrorMessage'> & {\n  index: number\n}\n\nexport type FormFieldType<T> = {\n  /** enum to determine if the field is a picker, text input, or checkbox selector */\n  fieldType: FieldType\n  /** props to pass into form input component */\n  fieldProps: VASelectorProps | VATextInputProps | VAModalPickerProps | RadioGroupProps<T> | FormAttachmentsProps\n  /** optional error message to display if the field is required and it hasn't been filled */\n  fieldErrorMessage?: string\n  /** optional boolean that prevents the field from being displayed when set to true */\n  hideField?: boolean\n  /** optional list of validation functions to check against */\n  validationList?: Array<ValidationFunctionItems>\n}\n\n/**\n * Props for FormWrapper component\n */\ntype FormWrapperProps<T> = {\n  /** list of form field objects to display */\n  fieldsList: Array<FormFieldType<T>>\n  /** callback called when onSaveClicked is true and there are no field errors */\n  onSave: () => void\n  /** boolean that when set to true calls the form validation and set field errors if they exist, otherwise it calls onSave */\n  onSaveClicked: boolean\n  /** callback that updates the onSaveClicked prop */\n  setOnSaveClicked: (value: boolean) => void\n  /** optional callback that sets to true if the form currently has an error */\n  setFormContainsError?: (containsError: boolean) => void\n  /** optional boolean that resets all field errors when set to true */\n  resetErrors?: boolean\n  /** optional callback to set the resetErrors prop. must be set when resetErrors is set. */\n  setResetErrors?: (value: boolean) => void\n  /** optional callback to return a list of errors and keys for alertBox functionality  */\n  setErrorList?: (errors: { [key: number]: string }) => void\n}\n\n/**A common component to wrap forms in that handles error states of each field*/\nconst FormWrapper = <T,>({\n  fieldsList,\n  onSave,\n  setFormContainsError,\n  resetErrors,\n  setResetErrors,\n  onSaveClicked,\n  setOnSaveClicked,\n  setErrorList,\n}: FormWrapperProps<T>): ReactElement => {\n  const theme = useTheme()\n  const [errors, setErrors] = useState<{ [key: number]: string }>({})\n\n  const updateFormContainsErrors = useCallback(\n    (value: boolean) => {\n      setFormContainsError && setFormContainsError(value)\n    },\n    [setFormContainsError],\n  )\n\n  useEffect(() => {\n    // if resetErrors is true, it clears the errors object\n    if (resetErrors) {\n      setErrors({})\n      updateFormContainsErrors(false)\n      setResetErrors && setResetErrors(false)\n      setErrorList && setErrorList([])\n    }\n  }, [resetErrors, setErrors, updateFormContainsErrors, setResetErrors, setErrorList])\n\n  // when onSaveClicked is true, it checks if all required fields are filled and if the validation functions pass. if true,\n  // calls onSave callback, otherwise calls setErrorsOnFormSaveFailure to update the error messages for the required\n  // fields that are not filled / failing validation functions\n  const onFormSave = useCallback(() => {\n    // Adds the field \"index\", which is the index of the field in the fieldsList, to each item\n    const getFieldListsWithIndexes = (): Array<FormFieldTypeWithUId<T>> => {\n      return fieldsList.map((obj, index) => ({ ...obj, index }))\n    }\n\n    // Using the fieldsList with the index fields, this returns all fields that are required but are\n    // empty or set to false (checkbox)\n    const getAllRequiredFieldsNotFilled = (): Array<FormFieldTypeWithUId<T>> => {\n      const fieldsListWithUIds = getFieldListsWithIndexes()\n\n      return fieldsListWithUIds.filter((el) => {\n        switch (el.fieldType) {\n          case FieldType.TextInput:\n            const textInputProps = el.fieldProps as VATextInputProps\n            return !textInputProps.value && textInputProps.isRequiredField\n          case FieldType.Picker:\n            const pickerProps = el.fieldProps as VAModalPickerProps\n            return !pickerProps.selectedValue && pickerProps.isRequiredField\n          case FieldType.Selector:\n            const checkboxProps = el.fieldProps as VASelectorProps\n            return !checkboxProps.selected && checkboxProps.isRequiredField\n          default:\n            // default returns false because the radio group and form attachments will not have field errors\n            return false\n        }\n      })\n    }\n\n    // Iterates over all required form fields that are not filled and updates the error messages for these fields\n    const setErrorsOnFormSaveFailure = (\n      requiredFieldsNotFilled: Array<FormFieldTypeWithUId<T>>,\n      errorsFromValidationFunctions: { [key: number]: string },\n    ): void => {\n      const updatedErrors: { [key: number]: string } = {}\n      _.forEach(requiredFieldsNotFilled, (field) => {\n        updatedErrors[field.index] = field.fieldErrorMessage || ''\n      })\n\n      const updatedErrorsObj = { ...errors, ...errorsFromValidationFunctions, ...updatedErrors }\n\n      setErrors(updatedErrorsObj)\n      setErrorList && setErrorList(updatedErrorsObj)\n    }\n\n    // Returns any errors to be set if a validation function failed\n    const checkAgainstValidationFunctions = () => {\n      const updatedErrors: { [key: number]: string } = {}\n\n      _.forEach(fieldsList, (field, index) => {\n        if (field.validationList) {\n          const result = field.validationList.filter((el) => {\n            return el.validationFunction()\n          })\n\n          // if there are items in the result that means that that validation function failed\n          if (result.length > 0) {\n            _.forEach(result, (item) => {\n              updatedErrors[index] = item.validationFunctionErrorMessage\n            })\n          }\n        }\n      })\n\n      return updatedErrors\n    }\n\n    const requiredFieldsNotFilled = getAllRequiredFieldsNotFilled()\n    const errorsFromValidationFunctions = checkAgainstValidationFunctions()\n\n    if (requiredFieldsNotFilled.length === 0 && _.isEmpty(errorsFromValidationFunctions)) {\n      if (!_.isEmpty(errors)) {\n        setErrors({})\n      }\n\n      updateFormContainsErrors(false)\n      onSave()\n    } else {\n      updateFormContainsErrors(true)\n      setErrorsOnFormSaveFailure(requiredFieldsNotFilled, errorsFromValidationFunctions)\n    }\n  }, [onSave, updateFormContainsErrors, errors, fieldsList, setErrorList])\n\n  useEffect(() => {\n    if (onSaveClicked) {\n      onFormSave()\n      setOnSaveClicked(false)\n    }\n  }, [onSaveClicked, onFormSave, setOnSaveClicked])\n\n  // sets the field error in the errors object based on its index, if its a string it sets it to the given errorMessage\n  // otherwise, it sets it to the fieldErrorMessage if it exists\n  const setFormError = (\n    errorMessage: string | undefined,\n    index: number,\n    fieldErrorMessage: string | undefined,\n  ): void => {\n    if (typeof errorMessage === 'string') {\n      const updatedErrors = { ...errors, [index]: errorMessage }\n      setErrors(updatedErrors)\n      const errorStillExists = _.values(updatedErrors).some((el) => el !== '')\n\n      if (errorStillExists) {\n        updateFormContainsErrors(true)\n      }\n\n      return\n    }\n\n    updateFormContainsErrors(true)\n\n    if (fieldErrorMessage) {\n      setErrors({ ...errors, [index]: fieldErrorMessage })\n    }\n  }\n\n  // returns the corresponding component based on the fields fieldType\n  const getFormComponent = (field: FormFieldType<T>, index: number): ReactElement => {\n    const { fieldType, fieldProps, fieldErrorMessage } = field\n\n    switch (fieldType) {\n      case FieldType.Picker:\n        return (\n          <VAModalPicker\n            {...(fieldProps as VAModalPickerProps)}\n            setError={(errorMessage?: string) => setFormError(errorMessage, index, fieldErrorMessage)}\n            error={errors[index]}\n          />\n        )\n      case FieldType.TextInput:\n        return (\n          <VATextInput\n            {...(fieldProps as VATextInputProps)}\n            setError={(errorMessage?: string) => setFormError(errorMessage, index, fieldErrorMessage)}\n            error={errors[index]}\n          />\n        )\n      case FieldType.Selector:\n        return (\n          <VASelector\n            {...(fieldProps as VASelectorProps)}\n            setError={(errorMessage?: string) => setFormError(errorMessage, index, fieldErrorMessage)}\n            error={errors[index]}\n          />\n        )\n      case FieldType.Radios:\n        return <RadioGroup {...(fieldProps as RadioGroupProps<T>)} />\n      case FieldType.FormAttachmentsList:\n        return <FormAttachments {...(fieldProps as FormAttachmentsProps)} />\n    }\n  }\n\n  const generateForm = (): ReactElement[] => {\n    return _.map(fieldsList, (field, index) => {\n      return (\n        <Box\n          mt={index === 0 ? 0 : theme.dimensions.formMarginBetween}\n          key={index}\n          display={field.hideField ? 'none' : undefined}>\n          {getFormComponent(field, index)}\n        </Box>\n      )\n    })\n  }\n\n  return <Box>{generateForm()}</Box>\n}\n\nexport default FormWrapper\n";var i=n(7644);const a={},l=void 0,d={unversionedId:"Flagship design library/Components/Selection and Input/Form Elements/FormWrapper",id:"Flagship design library/Components/Selection and Input/Form Elements/FormWrapper",title:"FormWrapper",description:"",source:"@site/docs/Flagship design library/Components/Selection and Input/Form Elements/FormWrapper.mdx",sourceDirName:"Flagship design library/Components/Selection and Input/Form Elements",slug:"/Flagship design library/Components/Selection and Input/Form Elements/FormWrapper",permalink:"/va-mobile-app/docs/Flagship design library/Components/Selection and Input/Form Elements/FormWrapper",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"FormAttachments",permalink:"/va-mobile-app/docs/Flagship design library/Components/Selection and Input/Form Elements/FormAttachments"},next:{title:"Radio button",permalink:"/va-mobile-app/docs/Flagship design library/Components/Selection and Input/Form Elements/RadioButton"}},p={},c=[],m="<FormWrapper \nfieldsList={pickerField} \nonSave={onUpload} \nonSaveClicked={onSaveClicked} \nsetOnSaveClicked={setOnSaveClicked} />",u={toc:c,exampleString:m},f="wrapper";function F(e){let{components:r,...n}=e;return(0,o.yg)(f,(0,t.A)({},u,n,{components:r,mdxType:"MDXLayout"}),(0,o.yg)(i.A,{componentName:"FormWrapper",example:m,codeString:s,mdxType:"ComponentTopInfo"}))}F.isMDXComponent=!0}}]);